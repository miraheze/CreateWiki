<?php

namespace Miraheze\CreateWiki\Services;

use MediaWiki\Config\ServiceOptions;
use MediaWiki\MainConfigNames;
use Miraheze\CreateWiki\ConfigNames;
use Miraheze\CreateWiki\Hooks\CreateWikiHookRunner;
use ObjectCacheFactory;
use stdClass;
use Wikimedia\AtEase\AtEase;
use Wikimedia\ObjectCache\BagOStuff;
use Wikimedia\Rdbms\IReadableDatabase;
use Wikimedia\StaticArrayWriter;
use function array_keys;
use function file_put_contents;
use function function_exists;
use function is_array;
use function opcache_invalidate;
use function rename;
use function tempnam;
use function time;
use function unlink;

/** @codeCoverageIgnore Tested through SetupAfterCache and other tests. */
class CreateWikiDataStore {

	public const CONSTRUCTOR_OPTIONS = [
		ConfigNames::CacheDirectory,
		ConfigNames::CacheType,
		MainConfigNames::CacheDirectory,
		MainConfigNames::LocalDatabases,
	];

	private const CACHE_KEY = 'CreateWiki';

	private readonly BagOStuff $cache;
	private IReadableDatabase $dbr;

	private readonly string $cacheDir;
	private int $timestamp;

	public function __construct(
		ObjectCacheFactory $objectCacheFactory,
		private readonly CreateWikiDatabaseUtils $databaseUtils,
		private readonly CreateWikiHookRunner $hookRunner,
		private readonly ServiceOptions $options
	) {
		$options->assertRequiredOptions( self::CONSTRUCTOR_OPTIONS );

		$this->cache = ( $this->options->get( ConfigNames::CacheType ) !== null ) ?
			$objectCacheFactory->getInstance( $this->options->get( ConfigNames::CacheType ) ) :
			$objectCacheFactory->getLocalClusterInstance();

		$this->cacheDir = $this->options->get( ConfigNames::CacheDirectory ) ?:
			$this->options->get( MainConfigNames::CacheDirectory );

		$this->timestamp = (int)$this->cache->get(
			$this->cache->makeGlobalKey( self::CACHE_KEY, 'databases' )
		);
	}

	/**
	 * Syncs the cache by checking if the cached database list is outdated.
	 * If the database cache file has been modified, it will reset
	 * and regenerate the cached data.
	 */
	public function syncCache(): void {
		if ( !$this->timestamp ) {
			$this->resetDatabaseLists( isNewChanges: true );
			return;
		}

		// mtime will be 0 if the file does not exist as well, which means
		// it will be generated.
		$mtime = $this->getCachedDatabaseList()['mtime'] ?? 0;

		// Regenerate database list cache if the databases.php file does not
		// exist or has no valid mtime
		if ( $mtime === 0 || $mtime < $this->timestamp ) {
			$this->resetDatabaseLists( isNewChanges: false );
		}
	}

	public function getAllDatabases(): array {
		$data = $this->getCachedDatabaseList();
		if ( isset( $data['databases'] ) ) {
			return array_keys( $data['databases'] );
		}

		return $this->options->get( MainConfigNames::LocalDatabases );
	}

	/**
	 * Resets the cached database lists by fetching the current lists from the database.
	 * This function queries the 'cw_wikis' table for database names and clusters, and writes
	 * the updated list to a PHP file within the cache directory. It also updates the
	 * modification time (mtime) and stores it in the cache for future reference.
	 */
	public function resetDatabaseLists( bool $isNewChanges ): void {
		$mtime = time();
		if ( $isNewChanges ) {
			$this->timestamp = $mtime;
			$this->cache->set(
				$this->cache->makeGlobalKey( self::CACHE_KEY, 'databases' ),
				$mtime
			);
		}

		$databaseLists = [];
		$this->hookRunner->onCreateWikiGenerateDatabaseLists( $databaseLists );

		if ( $databaseLists ) {
			foreach ( $databaseLists as $name => $content ) {
				$list = [
					'mtime' => $mtime,
					'databases' => $content,
				];

				$this->writeToFile( $name, $list );
			}

			return;
		}

		$this->dbr ??= $this->databaseUtils->getGlobalReplicaDB();
		$databaseList = $this->dbr->newSelectQueryBuilder()
			->table( 'cw_wikis' )
			->fields( [
				'wiki_dbcluster',
				'wiki_dbname',
				'wiki_deleted',
				'wiki_sitename',
				'wiki_url',
			] )
			->caller( __METHOD__ )
			->fetchResultSet();

		$databases = [];
		foreach ( $databaseList as $row ) {
			if ( !$row instanceof stdClass ) {
				// Skip unexpected row
				continue;
			}

			$databases[$row->wiki_dbname] = [
				's' => $row->wiki_sitename,
				'c' => $row->wiki_dbcluster,
			];

			if ( $row->wiki_url !== null ) {
				$databases[$row->wiki_dbname]['u'] = $row->wiki_url;
			}
		}

		$list = [
			'mtime' => $mtime,
			'databases' => $databases,
		];

		$this->writeToFile( 'databases', $list );
	}

	/**
	 * Writes data to a PHP file in the cache directory.
	 */
	private function writeToFile( string $fileName, array $data ): void {
		$tmpFile = tempnam( $this->cacheDir, $fileName );
		if ( $tmpFile !== false ) {
			$contents = StaticArrayWriter::write( $data, 'Automatically generated by CreateWiki' );
			if ( file_put_contents( $tmpFile, $contents ) ) {
				$targetFilename = "{$this->cacheDir}/$fileName.php";
				if ( rename( $tmpFile, $targetFilename ) ) {
					if ( function_exists( 'opcache_invalidate' ) ) {
						opcache_invalidate( $targetFilename, true );
					}
				} else {
					unlink( $tmpFile );
				}
			} else {
				unlink( $tmpFile );
			}
		}
	}

	private function getCachedDatabaseList(): array {
		// Avoid using file_exists for performance reasons. Including the file directly leverages
		// the opcode cache and prevents any file system access.
		// We only handle failures if the include does not work.

		$filePath = "{$this->cacheDir}/databases.php";
		$cacheData = AtEase::quietCall(
			static fn ( string $path ): array|false => include $path,
			$filePath
		);

		if ( is_array( $cacheData ) ) {
			return $cacheData;
		}

		return [ 'mtime' => 0 ];
	}
}
